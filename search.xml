<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux常用命令之用户权限]]></title>
    <url>%2F2018%2F10%2F20%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[之前的一篇文章讲到了Linux操作系统的远程管理相关的终端命令，这篇文章我们来谈谈与用户权限有关的终端命令，毕竟我们也是经常与权限打交道。主要包含以下三块： 用户和权限的基本概念 用户管理终端命令 组管理终端命令 修改权限终端命令(有一篇单独的博文具体讲过了，这里再提一下) 用户和权限的基本概念基本概念 用户是Linux系统工作中重要的一环，用户管理包括用户与组管理 在Linux系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限 在Linux中，可以指定每一个用户针对不同的文件或者目录的不同权限 对文件/目录的权限包括： 序号 权限 英文 缩写 数字代号 01 读 read r 4 02 写 write w 2 03 执行 execute x 1 组 为了方便用户的管理，提出了组的概念，如下图所示： 在实际应用中，可以预先针对组设置好权限，然后将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 ls -l扩展 ls -l可以查看文件夹下文件的详细信息，从左到右依次是: 权限，第 1 个字符如果是d表示目录,如果是-表示文件 硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件 拥有者，家目录下文件／目录的拥有者通常都是当前用户 组，在Linux中，很多时候，会出现组名和用户名相同的情况，后续会讲 大小 时间 名称 chmod简单使用（重要） chmod可以修改用户／组对文件／目录的权限 命令格式如下：1chmod +/-rwx 文件名|目录名 超级用户 Linux系统中的root账号通常用于系统的维护和管理，对操作系统的所有资源具有所有访问权限 在大多数版本的Linux中，都不推荐直接使用root账号登录系统 在Linux安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户” sudo su是substitute user的缩写，表示使用另一个用户的身份 sudo命令用来以其他身份来执行命令，预设的身份为root 用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码 若其未经授权的用户企图使用sudo，则会发出警告邮件给管理员 组管理终端命令 提示：创建组/删除组的终端命令都需要通过sudo执行 序号 命令 作用 01 groupadd 组名 添加组 02 groupdel 组名 删除组 03 cat/etc/group 确认组信息 04 chgrp -R 组名 文件/目录名 递归修改文件/目录的所属组 提示： 组信息保存在/etc/group文件中 etc目录是专门用来保存系统配置信息的目录 在实际应用中，可以预先针对组设置好权限，然后将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 用户管理终端命令 提示：创建用户/删除用户/修改其他用户密码的终端命令都需要通过sudo执行 创建用户/设置密码/删除用户 序号 命令 作用 说明 01 useradd -m -g 组 新建用户名 添加新用户 -m自动建立用户家目录-g指定用户所在的组，否则会建立一个和同名的组 02 passwd 用户名 设置用户密码 如果是普通用户，直接用passwd可以修改自己的账户密码 03 userdel -r 用户名 删除用户 -r选项会自动删除用户家目录 04 cat /etc/passwd 确认用户信息 新建用户后，用户信息会保存在 /etc/passwd文件中 提示： 创建用户时，如果忘记添加-m选项指定新用户的家目录—最简单的方法就是删除用户，重新创建 创建用户时，默认会创建一个和用户名同名的组名 用户信息保存在/etc/passwd文件中 查看用户信息 序号 命令 作用 01 id[用户名] 查看用户 UID 和 GID 信息 02 who 查看当前所有登录的用户列表 03 whoami 查看当前登录用户的账户名 password文件etc/passwd文件存放的是用户的信息，由6个分号组成的7个信息，分别是： 用户名 密码(x，表示加密的密码) UID(用户标识) GID(组标识) 用户全名或本地账号 家目录 登录使用的Shell，就是登录之后，使用的终端命令，ubuntu默认是dash usermod usermod可以用来设置用户的主组／附加组和登录 Shell，命令格式如下: 主组: 通常在新建用户时指定，在etc/passwd的第4列GID对应的组 附加组: 在etc/group中最后一列表示该组的用户列表，用于指定用户的附加权限 提示：设置了用户的附加组之后，需要更新登陆才能生效。 12345678# 修改用户的主组（passwd 中的 GID）usermod -g 组 用户名# 修改用户的附加组usermod -G 组 用户名# 修改用户登录 Shellusermod -s /bin/bash 用户名 注意：默认使用useradd添加的用户是没有权限使用sudo以root身份执行命令的，可以使用以下命令，将用户添加到sudo附加组中 1usermod -G sudo 用户名 which(重要) 提示： /etc/passwd是用于保存用户信息的文件 /usr/bin/passwd是用于修改用户密码的程序 which命令可以查看执行命令所在的位置，例如： 123456789which ls# 输出# /bin/lswhich useradd# 输出# /usr/sbin/useradd bin和sbin 在Linux中，绝大多数可执行文件都是保存在/bin、/sbin、/usr/bin、/usr/sbin /bin（binary）是二进制执行文件目录，主要用于具体应用 /sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理 /usr/bin（user commands for applications）后期安装的一些软件 /usr/sbin（super user commands for applications）超级用户的一些管理程序 提示： cd这个终端命令是内置在系统内核中的，没有独立的文件，因此用which无法找到 cd命令的位置 切换用户 序号 命令 作用 说明 01 su - 用户名 切换用户，并且切换目录 -可以切换到用户家目录，否则保持位置不变 02 exit 退出当前登录账户 su不接用户名，可以切换到root,但是不推荐使用，因为不安全 exit示意图如下： 修改文件权限 序号 命令 作用 01 chown 修改拥有者 02 chgrp 修改组 03 chmod 修改权限 命令格式如下： 12345678# 修改文件|目录的拥有者chown 用户名 文件名|目录名# 递归修改文件|目录的组chgrp -R 组名 文件名|目录名# 递归修改文件权限chmod -R 755 文件名|目录名 chmod在设置权限时，可以简单地使用三个数字分别对应拥有者/组和其他用户的权限 12# 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他chmod +/-rwx 文件名|目录名 常见的数字组合有(u表示用户／g表示组／o表示其他)： 777 ===&gt; u=rwx,g=rwx,o=rwx 755 ===&gt; u=rwx,g=rx,o=rx 644 ===&gt; u=rw,g=r,o=r]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令之远程管理]]></title>
    <url>%2F2018%2F10%2F20%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前的一篇文章讲到了Linux操作系统的与目录和文件相关的终端命令，目录和文件相关的命令也是我们用的最多的命令。这篇文章我们来谈谈与远程管理有关的终端命令，主要包含以下三块： 关机/重启： shutdown 查看或者配置网卡信息： ifconfig ping 远程登录和复制文件： ssh scp 下面我们就来具体来看看这几个命令。 shutdownshutdown命令可以安全关闭或者重新启动系统。 常见的用法为： 1~/Documents$ shutdown 选项 时间 注意： 不指定选项和参数，默认表示1分钟之后关闭电脑。 远程维护服务器时，最好不要关闭系统，而应该重新启动系统。 12~/Documents$ shutdown -r# -r表示重新启动系统 常用命令示例： 1234567891011121314# 重新启动操作系统，其中 now 表示现在$ shutdown -r now# 立刻关机，其中 now 表示现在$ shutdown now# 系统在今天的 20:25 会关机$ shutdown 20:25# 系统再过十分钟后自动关机$ shutdown +10# 取消之前指定的关机计划$ shutdown -c ifconfigifconfig可以查看/配置计算机当前的网卡配置信息 12345# 查看网卡配置信息$ ifconfig# 查看网卡对应的 IP 地址$ ifconfig | grep inet 提示： 一台计算机中有可能会有一个物理网卡和多个虚拟网卡，在 Linux中物理网卡的名字通常以ensXX表示. 127.0.0.1被称为本地回环/环回地址，一般用来测试本机网卡是否正常 pingping一般用于检测当前计算机到目标计算机之间的网络是否通畅，数值越大，速度越慢 12345# 检测到目标主机是否连接正常$ ping IP地址# 检测本地网卡工作正常$ ping 127.0.0.1 Notes: ping的工作原理与潜水艇的声纳相似，ping这个命令就是取自声纳的声音 网络管理员之间也常将ping用作动词——ping一下计算机X，看他是否开着 ping的原理：网络上的机器都有唯一确定的IP地址，我们给目标IP地址**发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在 ssh基础(重点)在Linux中SSH是非常常用的工具，通过SSH客户端我们可以连接到运行了SSH服务器的远程机器上. SSH客户端是一种使用Secure Shell(SSH)协议连接到远程计算机的软件程序 SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议 利用SSH协议可以有效防止远程管理过程中的信息泄露 通过SSH协议可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗 SSH的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度 1) 域名和端口号 域名: 由一串用点分隔的名字组成，例如：www.baidu.com 是IP地址的别名，方便用户记忆 端口号: IP地址: 通过IP地址找到网络上的计算机 端口号: 通过端口号可以找到计算机上运行的应用程序 SSH服务器的默认端口号是22,如果是默认端口号，在连接的时候，可以忽略 常见服务器端口号： 序号 服务 端口号 01 SSH服务器 22 02 Web服务器 80 03 HTTPS服务器 443 04 FTP服务器 21 1) SSH客户端的简单使用 1ssh [-p port] user@remote user是在远程机器上的用户名,如果不指定的话默认为当前用户 remote是远程机器的地址，可以是IP/域名，或者是后面会提到的别名 port是SSH Server监听的端口，如果不指定，就默认为22 使用exit退出当前用户的登录 注意： SSH这个终端命令只能在Linux或者UNIX系统下使用 如果在Windows系统中，可以安装PuTTY或者XShell客户端软件即可 scpscp就是secure copy，是一个在Linux下用来进行远程拷贝文件的命令它的地址格式与SSH基本相同，需要注意的是， 在指定端口时用的是大写的-P而不是小写的 12345678910111213# 把本地当前目录下的01.py文件复制到远程Home目录下的Desktop/01.py# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop/01.py# 把远程Home目录下的Desktop/01.py文件复制到本地当前目录下的01.pyscp -P port user@remote:Desktop/01.py 01.py# 加上-r选项可以传送文件夹# 把当前目录下的demo文件夹复制到远程Home目录下的Desktopscp -r demo user@remote:Desktop# 把远程Home目录下的Desktop复制到当前目录下的demo文件夹scp -r user@remote:Desktop demo 选项 含义 -r 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -P 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口 注意： scp这个终端命令只能在Linux或者UNIX系统下使用 如果在Windows系统中，可以安装PuTTY, 使用pscp命令行工具或者安装 FileZilla使用FTP进行文件传输 FileZilla在传输文件时，使用的是FTP服务而不是SSH服务，因此端口号应该设置为 21 ssh高级(知道) 免密码登陆 配置别名 注意：有关SSH配置信息都保存在用户家目录下的.ssh目录下 1) 免密码登陆： 步骤： 配置公钥： 执行ssh-keygen即可生成SSH钥匙，一路回车即可 上传公钥到服务器： 执行ssh-copy-id -p port user@remote,可以让远程服务器记住我们的公钥 示意图： 非对称加密算法 使用公钥加密的数据，需要使用私钥解密 使用私钥加密的数据，需要使用公钥解密 2) 配置别名： 每次都输入ssh -p port user@remote，时间久了会觉得很麻烦，特别是当user, remote和port都得输入，而且还不好记忆 而配置别名可以让我们进一步偷懒，譬如用：ssh mac来替代上面这么一长串，那么就在 ~/.ssh/config里面追加以下内容：1234Host mac HostName ip地址 User itheima Port 22 保存之后，即可用ssh mac实现远程登录了，scp同样可以使用]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github如何同步更新一个你Fork的仓库？]]></title>
    <url>%2F2018%2F06%2F12%2FGithub-%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E4%BD%A0Fork%E7%9A%84%E4%BB%93%E5%BA%93%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我们在进行Github协同开发的时候，往往会去fork一个仓库到自己的Github中，过一段时间以后，原仓库可能会有各种提交以及修改，很可惜，Github本身并没有自动进行同步的机制，这个需要我们手动去执行，现在我来演示一下如何进行自己的仓库和原仓库进行Gith同步的操作。重点在于：除了origin以外，增加一个upstream，来跟踪原仓库的更新。 先将你fork到自己的Github的远程仓库克隆到本地1$ git clone https://github.com/zmzhouXJTU/Problem-sets 查看远程仓库的信息123$ git remote -vorigin https://github.com/zmzhouXJTU/Problem-sets (fetch)origin https://github.com/zmzhouXJTU/Problem-sets (push) 配置原远程仓库(即你所fork的)的路径1$ git remote add upstream https://github.com/ACLoong/Problem-sets 再次查看远程仓库信息确定是否配置成功12345$ git remote -vorigin https://github.com/zmzhouXJTU/Problem-sets (fetch)origin https://github.com/zmzhouXJTU/Problem-sets (push)upstream https://github.com/ACLoong/Problem-sets (fetch)upstream https://github.com/ACLoong/Problem-sets (push) 抓取原仓库的更新文件，该文件会被存储在一个本地分支upstream/master上1234567$ git fetch upstreamremote: Counting objects: 21, done.remote: Compressing objects: 100% (15/15), done.remote: Total 21 (delta 4), reused 5 (delta 1), pack-reused 0Unpacking objects: 100% (21/21), done.From https://github.com/ACLoong/Problem-sets * [new branch] master -&gt; upstream/master 切换到本地主分支(如果当前不在的话)12$ git checkout master# Switched to branch 'master' 将原仓库的更新文件(即存储在本地的upstream/master分支上的文件)与本地仓库的当前分支合并123456$ git merge upstream/masterUpdating 60b537a..426148cFast-forward problem_set/first_week/refs/Process&amp;Thread.md | 29 +++++++++++++++++++++++++++ 1 file changed, 29 insertions(+) create mode 100644 problem_set/first_week/refs/Process&amp;Thread.md Note: 此时，你的本地仓库已经和原来仓库完全同步了。但是注意，此时只是你电脑上的本地仓库和原作者的远程github仓库同步了，你fork到自己的github远程仓库还没有同步。要想实现本地和自己的Github远程仓库的同步，只需要如下操作即可： 将其更新到自己的Github远程仓库，可以利用命令git push origin master来实现123456789$ git push origin masterCounting objects: 21, done.Delta compression using up to 4 threads.Compressing objects: 100% (16/16), done.Writing objects: 100% (21/21), 5.65 KiB | 1.88 MiB/s, done.Total 21 (delta 4), reused 0 (delta 0)remote: Resolving deltas: 100% (4/4), completed with 2 local objects.To https://github.com/zmzhouXJTU/Problem-sets 60b537a..426148c master -&gt; master 好了，至此任务就完成了。不知你是否看明白了呢？有任何问题，欢迎在此博客下方评论留言。]]></content>
      <categories>
        <category>版本控制之Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件权限]]></title>
    <url>%2F2018%2F04%2F26%2FLinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[在 Linux 操作系统中，权限是一个非常重要的东西。 它无时无刻不在影响着你的各种操作。就像有的时候，你想去百度云下载一些别人分享的文件，可是你却发现虽然你能看到文件但是你却不能下载，这就是一种权限的典型例子。在 Linux 中, 这种权限随处可见。你可以设置，让别人不能越界。 不过像我这种人，也就是一台电脑， 一个用户(手动滑稽)，涉及不到多少有关权限方面的问题。 如果你也和我差不多，只有你自己在用 Linux 的电脑，主要用它来运行你的代码。我教你一招来修改权限，并且方便运行你的Python脚本的招数。 这里不会涉及过深的权限管理。我们了解一些基础，方便你拿你的Linux跑机器学习的代码就好。如果你想扩展学习的话, 网上会有很多教程。可以自行谷歌。 ls查看权限查看文件权限的方法很简单，其实在之前我的上一篇博文就讲了这个内容。 如果你还记得的话，我们在说 ls指令的时候, 提到过权限问题， 不过到了这节内容我们仔细的来说一说权限。如果你在 Terminal 中输入如下图片中的指令： 如上图所示，在 Terminal 中查看文件的权限的命令可以用ls -l 或者ls -lh，这个是看当前目录下面所有文件的权限，如果你只是想单独看看某一个具体的文件的权限，只需要在后面加上相应的文件名就可以了，比如ls -lh p1.py。 我们看到的上图中的-rw-rw-r--就是相关的权限啦。那么这些具体又是表达什么意思的呢？看下面的图就明白啦。 Type: 很多种 (最常见的是 - 为文件, d 为文件夹, 其他的还有l, n … 这种东西, 真正自己遇到了, 网上再搜就好, 一次性说太多记不住的)。 User: 后面跟着的三个空是使用 User 的身份能对这个做什么处理 (r 可读; w 可写; x 可执行; - 不能完成某个操作)。 Group: 一个 Group 里可能有一个或者多个 user, 这些权限的样式和 User 一样。 Others: 除了 User 和 Group 以外人的权限。 如果有人对 User, group, others 这三个没什么概念的话，我这里补充一下。User 一般就是指你，这个当前正在使用电脑的人。 Group 是一个 User 的集合，最开始创建新 User 的时候, 他也为这个 User 创建了一个和 User 一样名字的 Group, 这个新 Group 里只有这个 User。一般来说，像一个企业部门的电脑，都可以放在一个 Group 里, 分享了一些共享文件和权限。Others 就是除了上面提到的 User 和 Group 以外的人。 好了, 有了这些理解, 我们拿上面的 p1.py 来举例. 我们可以将 -rw-rw-r-- 拆成 - (这是文件), -rw(这个 User可以读,写), rw- (这个Group里可以读,写), r– (其他人只能读)。 chmod 修改权限好了, 我们知道了这些权限的问题, 那我们如何来改写权限呢? chmod (change mode)命令就是来干这个的。 通常的修改形式是： 1~$ chmod [谁] [怎么修改] [哪个文件] 举个最简单的例子, 现在的 p1.py 的权限是 -rw-rw-r--, 如果我们想让user和group拥有执行的能力。按照下面这样来改就行了。相应的结果如下图所示： 这里的 ug+x 很形象, User,Group + execute , 给 p1.py 这个文件进行修改。所以我们的修改形式就能总结出下面这样： [谁] u: 对于 User 修改 g: 对于 Group 修改 o: 对于 Others 修改 a: (all) 对于所有人修改 [怎么修改] +, -, =: 作用的形式, 加上, 减掉, 等于某些权限 r, w, x 或者多个权限的组合, 比如 rx [哪个文件] 施加操作的文件, 可以为多个文件 除了上面这些修改形式, 还有一些简化版的形式, 就是用数字来表示相应的权限，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 文件默认权限 文件默认权限：文件默认没有可执行权限，因此为666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为777 ，也就是 drwxrwxrwx。 一个使用Python的技巧我不怎么用权限这东西, 但是我却发现给 python 文件添加权限x 还算有用的. 为什么这么说? 因为通常, 如果一个 .py 没有x 权限, 在 terminal 中你就需要这样执行: 1~/Documents/Folder1$ python3 p1.py 如果你有了 x (可执行权限), 你运行这个文件可以直接这样打: 1~/Documents/Folder1$ ./p1.py 很酷炫有木有？但是上面这个脚本能够成功运行有一个前提，那就是你在这个Python脚本p1.py的开头加上一句话，如下所示： 12#!/usr/bin/python3print("Hello World") 好了，加上上面这句话的话以后运行这个脚本就可以直接用那本很酷炫的方式而不用每次都python3 xx.py啦。]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令之目录和文件]]></title>
    <url>%2F2018%2F04%2F26%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[作为一名程序员，相信大家对Linux操作系统都不会陌生。但是Linux系统那些繁杂的操作命令通常让我们很头疼，我也在网上查阅了很多资料，做了一些总结。这里将常用的一些Linux操作命令(主要是与文件相关的操作命令)整理如下： sudo这个SuperUserDo(简写成”sudo”)是Linux新手要使用的最重要的命令。需要根权限的每一个命令都需要这个sudo命令。你可以在需要根权限的每个命令之前使用sudo 1$ sudo su pwd12~/Documents$ pwd# 获取当前所在的路径(绝对路径) ls(list)借助ls(list)命令，终端就会显示你正在处理的那个目录里面的所有文件和文件夹。假设我在Home目录(也就是”~”)里面，想查看当前目录下的文件夹和文件。相应的命令如下图所示： 12~$ ls# 显示当前目录的所有文件和文件夹 上面是ls命令最基本的使用方式，下面我们再看看ls命令其他的使用方式。 12~$ ls -l# 输出详细信息 -l (long 的简写). 这个指令会打印出文件的权限 (-rw-rw-r-- 之后我们在细说这个), 用户名, 文件大小, 修改日期, 文件名 12~$ ls -a# -a (all 的简写) 显示所有文件 . 这里还会显示隐藏的文件 (以 . 开头的) 12~$ ls -lh# -lh (human), 直接 -l 不方便人看, 这个指令是为了方便给人观看的. 注意这里的文件大小使用了 K, MB, GB 之类概括 12~$ ls --help# 还有很多其他的功能, 我们可以通过 --help 来查看 cd更改目录(cd)是始终在终端中使用的主要命令。它是最基本的Linux命令之一。使用这个命令很简单。只要输入你想要从当前目录进入到的那个文件夹的名称(如果是多层，中间用”/“进行分隔)。如果想要返回上一级，只要将双圆点(..)作为参数。 假设我在Home目录(也就是”~”)中，想进入到在Home目录里面的Documents子目录。下面是我可以使用cd命令的方法： 12~$ cd Documents/# 跳转到对应的Documents目录 若果要想返回到上一级目录，只用将双圆点(..)作为相应的参数即可。如下图所示： 12~/Documents$ cd ..# 返回上一级目录 除了上面两个基本的命令之外，还有一些有趣的，我们来看看。 12~$ cd Documents/Folder1/# 去往子文件夹Folder1 12~/Documents/Folder1$ cd -# 返回你刚刚所在的目录(也就是你的上一条命令所在的目录) 12~/Documents/Folder1$ cd ../../# 向上返回两次(再往上返回可以依次类推) 12~/Documents/Folder1$ cd ~# 去往当前用户的主目录 touchtouch 命令的意思的新建，它的使用很简单。我们先去往 Documents 的文件夹, 里面已经有了 folder1 和 file1, 如果我们想新建一个 file2 使用下面的语句就好(可以指定文件的扩展名)。一个空文件就这样建立好了。(注意：如果创建的文件不存在，则会创建一个空白文件；如果文件已经存在，可以修改文件的末次修改日期) 12~/Documents$ touch file2.txt# 建立一个文件名为file2的空的文本文档 如果你想同时建立多个文件，输入多个文件的名字，以空格分开。 12~/Documents$ touch file3.txt file4.txt file5.txt# 同时建立三个空的文本文档(也可以不指定文件的扩展名) treetree 命令的意思的新建，可以以树状图列出文件目录结构. 12~/Documents$ tree [目录名]# 查看当前目录下的文件目录结构 12~/Documents$ tree -d [目录名]# 只会显示当前目录下的目录结构而不显示文件结构 cp拷贝粘贴是我们为了组织整理文件而需要完成的重要任务。使用cp将帮助你从终端拷贝粘贴文件。首先，你确定想要拷贝的那个文件，然后输入目的地位置，即可粘贴文件。cp (copy) 是复制文件或者文件夹的指令, 常用的方式是复制 “源文件” 到 “目标文件”。即： 1~$ cp 源文件 目标文件 注意: 如果你将文件拷贝到任何新文件都需要根权限的目录，那么你就需要使用sudo命令。 下面是cp命令的一些常见操作。 12~/Documents$ cp file1 file1copy# 将file1复制成file1copy 123~/Documents$ cp -i file1 file1copy# -i (interactive) 注意: 如果 file1copy 已经存在, 它将会直接覆盖已存在的 file1copy, 如果要避免直接覆盖, 我们在 cp 后面加一个选项。# 在这句问句后面打上 “Yes”, “Y”, 或者任何大小写形式的 “y” 和 “yes”, 它将进行覆盖操作. 直接回车或者打其他字母, 就会放弃复制这项操作。 12~/Documents$ cp file1 Folder1/# 将file1复制到文件夹Folder1 12~/Documents$ cp -R Folder1/ Folder2/# 复制文件夹, 需要加上 -R (recursive) 12~/Documents$ cp file* Folder1/# 复制多个文件。复制名字部分相同的多个文件到某个文件夹, * 是说"你就找文件名前面是 file 的文件, 后面是什么名字无所谓" 12~/Documents$ cp file2.txt file5.txt Folder1/# 或者你可以单独选定几个文件, cp 会默认最后一个选项是要复制去的文件夹. 比如把 file2.txt 和 file5.txt 复制去 Folder1/ mv知道了 cp, mv就好理解多了, 基本是一样的。mv是剪切(移动)的命令。mv命令可以用来移动文件或目录，也可以给文件或目录重命名。下面是mv命令的一些常见操作。 12~/Documents$ mv file1 Folder1/# 将file1移动到文件夹Folder1 12~/Documents$ mv -i file1 file1rename# 重命名文件file1为file1rename。因为移动文件到原始的地点, 但是以不同的文件名。所以这种做法不就是在重命名嘛!(加上`-i`覆盖文件前提示) 12~/Documents$ mv -f file1 Folder2/# 将文件file1强制移动到Folder2文件夹下。如果目标文件已经存在，不会询问而会直接覆盖。 最后还是想要提一句, 如果想要查看使用说明, 直接在指令后面打上 --help就能查看. mkdir仅仅会更改目录还不全面。有时候，你想要创建一个新的文件夹或子文件夹。可以使用mkdir命令来做到这一点。只要在终端中将你的文件夹名称放在mkdir命令的后面即可。mkdir (make directory) 就是创建一个文件夹的意思, 使用起来很简单。(注意：新建目录的名称不能与当前目录中已有的目录或文件同名) 以下是mkdir命令的一些常见操作。 12~/Documents$ mkdir Folder2/# 在Documents文件夹下创建一个文件夹Folder2 12~/Documents$ mkdir Folder2/folder# 在文件夹Folder2里面再创建一个子文件夹folder 12~/Documents$ mkdir -p A/B/C/D# 可以递归的创建目录，此处创建了4个目录 rmdirrmdir(remove directory) 也就是字面的意思，即移除文件夹。不过这有一个前提条件. 这些要移除的文件夹必须是空的，不然会失败。所以如果想刚刚建立的那个 Folder2 就不能被移除, 因为里面有个 folder 文件夹。那么怎么移除有文件的文件夹呢？这里需要用到我们后面讲的rm命令。 要移除个空文件夹, 比如我在新建一个 Folder3, 然后移除。 12~/Documents$ rmdir Folder3# 删除文件夹Folder3(rmdir只能移除空文件夹！！！) rmrm这个命令可以移除你的文件，甚至移除你的目录。如果文件需要根权限才能移除，可以使用-f(强制删除)。你还可以使用-r来进行递归移除，从而移除你的文件夹。 注意: 执行了 rm以后是不能进行返回操作的, 请确保别执行像这样的操作 rm /(或者在根目录下进行rm -rf *)，这会清空你的电脑。 12~/Documents$ rm file1# 删除单个文件filer1 12345~/Documents$ rm -i file2# -i 或 -I 有提示地移除文件 (为了避免误删)# -i 会每个要移除的文件都进行提示~/Documents$ rm -I file2 fil3 file4 file5# -I 超过3个文件才进行提示 12~/Documents$ rm -f file1# 强制删除，忽略不存在的文件，无需提示 123~/Documents$ rm -r Folder1/# -r 或 -R (recursively) 用来删文件夹(递归的删除目录下的内容)# 和 rmdir 不同, rm -r 可以在文件夹中有文件的情况下删除这个文件夹. 比如我的 Folder1 里有 file1 和 file2 两个文件. rm命令其他的特点和cp命令差不多，比如用带相应的前缀或者后缀(或者不带，这样会清空当前文件夹下所有文件)加’*’来一次性删除多个文件。 nanonano是 linux 的一款文字编辑工具. 我们可以拿它来做最基本的 terminal 端的文本编辑, 甚至可以写代码。下面我们用 touch 创建一个 Python 脚本。如果大家不懂Python 也没关系，你就知道我们可以拿 nano来编辑文字或者脚本就好了。 12~/Documents$ touch p1.py# 在Documents目录下创建一个python文件 然后用 nano 执行这个 p1.py 文件，如下图所示： 12~/Documents$ nano p1.py# 用nano命令执行这个文件 它就会变成一个文本编辑器, 你在里面可以写上一些脚本。然后按 “Ctrl + x” 来保存和退出。如果提示你保存, 你就按一下 “y” 键, 然后回车, 你的文件就被保存下来了。 接着如果你在 terminal 中输入相关的执行python文件的命令，你就能看到 terminal 执行了你的 python 文件。 cat作为用户，你常常需要查看来自脚本的一些文档或代码。同样，其中一个Linux基本命令是cat命令。它会为你显示文件里面的文本。 cat(catenate) 可以用来显示文件内容,创建文件,文件合并, 或者是将某个文件里的内容写入到其他文件里。cat会一次性的显示所有的内容,适合查看内容较少的文本文件。详细的操作见下面。 1234~/Documents$ cat -b p1.py ~/Documents$ cat -n p1.py # -b表示对文件的非空输出行编号# -n表示对文件的所有行输出行编号 123~/Documents$ cat p1.py &gt; p2.py~/Documents$ cat p2.py# &gt; 将文件的内容放到另一个文件里，这里我们将p1.py的内容写入到p2.py里面。 1234~/Documents$ cat p1.py p2.py &gt; p3.py~/Documents$ cat p3.py# &gt; 将多个文件的内容打包一起放入另一个文件，这里我们将p1.py的内容和p1.py的内容一同写入到p2.py里面。# 在显示的时候，两个文件的内容会分开显示 123~/Documents$ cat p2.py &gt;&gt; p3.py~/Documents$ cat p3.py# &gt;&gt; 将内容添加在一个文件末尾，这里我们将p2.py的内容添加到p3.py的末尾。 more和上面的cat命令类似,more命令可以用于分屏显示文件内容，每次只显示一页内容。适合于查看内容较多的文本文件。 123~/Documents$ more p1.py# 分屏查看p1.py文件的内容。如果要查看后续的内容，可以按住空格键(显示手册页的下一屏)或者回车键(一次滚动手册页的一行)# b:回滚一屏 f:前滚一屏 q:退出 head查看文件的前几行(默认查看前10行) 123~/Documents$ head -n 5 p2.py# head [-n number] filename# -n ：后面接数字，代表显示几行的意思 tail查看文件的后几行(默认查看倒数后10行) 123~/Documents$ tail -n 6 p3.py# tail [-n number] filename# -n ：后面接数字，代表显示几行的意思 grep你需要找到一个文件，但是又记不得它的确切位置或路径。grep可以帮助你解决这个问题。你可以使用grep命令，根据给定的关键字帮助找到文件。 grep命令是Linux系统中一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 常用的两种正则表达式查找： ^a 行首，搜寻以 a 开头的行ke$ 行尾，搜寻以 ke 结束的行 1234567$ grep [-acinv] [--color=auto] 搜寻字符串 filename# -a ： 将 binary 文件以 text 文件的方式进行搜寻# -c ： 计算找到个数# -i ： 忽略大小写# -n ： 输出行号# -v ： 反向选择，亦即显示出 没有搜寻字符串内容 的那一行# --color=auto ：找到的关键字加颜色显示 12~/Documents$ grep hello p1.python# 在p1.py文件中搜索"hello"这个单词 范例：把含有 the 字符串的行提取出来(注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串) 1234567$ grep -n 'the' regular_express.txt# 以下为相应的显示结果# 8:I can't finish the test.# 12:the symbol '*' is represented as start.# 15:You are the best is mean you are the no. 1.# 16:The world Happy is the same with "glad".# 18:google is the best tools for search keyword 因为 {和 }在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。 1$ grep -n 'go\&#123;2,5\&#125;g' regular_express.txt grep还有很多更强大的用法，后续会继续更新。当然，具体的用法可以通过grep --help进行查看。 echoecho会在终端中显示参数指定的文字,通常会和重定向联合使用。 重定向&gt;和&gt;&gt;: Linux 允许将命令执行结果重定向到一个文件 将本应显示在终端上的内容 输出／追加到指定文件中 其中： &gt;表示输出，会覆盖文件原有的内容。 &gt;&gt;表示追加，会将内容追加到已有文件的末尾。 1234~/Documents$ echo Hello World &gt; 1.txt~/Documents$ echo Python &gt;&gt; 1.txt# 将'Hello World'写入到1.txt中# 将'Python'追加到1.txt文件的末尾 管道 | Linux允许将一个命令的输出可以通过管道做为另一个命令的输入 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里|的左右分为两端，左端塞东西（写），右端取东西（读） 常用的管道命令有： more: 分屏显示内容 grep: 在命令执行结果的基础上查询指定的文本 1~/Documents$ ls -lha | more apt-get就不同的发行版而言，这个命令各不相同。在基于Debian的Linux发行版中，想安装、移除和升级任何软件包，我们可以使用高级包装工具(APT)软件包管理器。apt-get命令可帮助你安装需要在Linux中运行的软件。这是个功能强大的命令行工具，可以执行安装、升级、甚至移除软件这类任务。 在其他发行版(比如Fedora和Centos)中，有不同的软件包管理器。Fedora过去有yum，但现在它有dnf。 1~ sudo apt-get update 1~ sudo dnf update 12~ sudo apt-get install &lt;package name&gt;# 安装相应的软件或工具 poweroff有时候，你需要直接从终端来进行关机。这个命令就能完成这项任务，别忘了在命令的开头添加sudo，因为它需要根权限才能执行poweroff。 1~$ sudo poweroff 结束语好了，基本的Linux命令大概就这么多。它会帮助你在这个早期阶段开始使用Linux，借助这些基本的Linux命令，开始使用Linux，并且定个目标：每天学会使用1个至3个命令。后续我也会继续更新~]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令整理]]></title>
    <url>%2F2018%2F04%2F24%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言碎碎念自从使用Git作为版本控制工具以来，通过教程学习、手册查阅方式了解了Git的相关原理和Git的命令，能够顺利使用。但由于还不熟练，实践经验也还不够丰富，每次遇到问题都需要重新搜索，多次下来十分麻烦。另一方面，查阅手册往往是不够的，因为手册只会告诉你什么命令做什么用，不会根据不同场景告诉你应该用什么命令。 所以在这篇文章中，我将常用的Git命令根据不同的使用场景做一个整理，加深印象的同时也方便自己日后进行查阅。 四个概念这里借用阮一峰老师的文章《常用Git命令清单》中的图。 几个专有名词的译名如下： Workspace: 工作区，也就是正在编辑的文件目录 Index / Stage: 暂存区 Repository: 本地仓库，.git文件夹管理的版本库 Remote: 远程仓库，也就是github.com上面的仓库 例如，在最常用的命令串中： 12345678$ git add &lt;file&gt;#添加工作区指定文件的改动到暂存区，"&lt;file&gt;"为"."时添加全部文件$ git commit -m "XXXX"#提交暂存区的所有内容到本地仓库的当前分支$ git push -u origin master#上传本地仓库到已关联的远程仓库 建立工程在工作目录中建立与远程仓库关联的Git工程主要有两种情况：第一种是由本地上传到远程仓库；第二种是从远程仓库克隆到本地。 本地上传在这种情况下，远程仓库应该是没有工程的。在本地工程文件夹下： 123456789101112$ git init#初始化一个Git仓库，此时当前目录会增加一个.git文件夹(此文件夹默认是隐藏的)，当前文件夹受到Git的管理，并默认创建master分支$ git add &lt;file&gt;#添加指定文件到暂存区，"&lt;file&gt;"为"."时表明添加当前目录的所有文件到暂存区$ git commit -m "XXXX"#提交暂存区的所有内容到本地仓库的当前分支$ git remote add origin &lt;url&gt;#为当前项目添加远程主机。#其中origin为自定义的远程主机名，url为远程主机的地址（推荐采用ssh协议） 此时已经建立了本地仓库与远程仓库的关联，可以通过git push推送上传。第一次推送采用： 12$ git push -u origin master#将本地master分支推送到远程同名分支（若不存在则新建），同时-u指定origin为默认主机名，之后若要上传到origin可省略它。 远程克隆这种情况下，远程仓库已经有工程，只需要在本地工程文件夹下用git clone命令克隆： 1$ git clone &lt;url&gt; 此时本地仓库已经与对应远程仓库建立关联，为主机名origin的地址。 克隆其他分支git clone命令默认克隆远程项目的master分支及其历史，若还需克隆别的分支，可通过以下方式进行（以克隆dev分支为例）： 12$ git checkout -b dev origin/dev#检出origin下的dev分支到本地新建的dev分支，并建立本地分支与远程分支的追踪关系 或者： 12345678$ git checkout -b dev#新建并切换到本地分支dev$ git branch --set-upstream-to=origin/dev dev#建立origin/dev远程分支和dev本地分支的追踪关系$ git pull#拉取本地分支dev对应的远程分支的最新状态 托管到新的远程仓库在克隆需要的内容后，有时会希望托管到新的远程仓库。此时可以增加新的远程主机名: 1$ git remote add &lt;new_remote_name&gt; &lt;url&gt; 或者干脆更改原来origin的地址： 1$ git remote origin set-url &lt;url&gt; 分支管理查看分支12345678$ git branch#查看本地分支$ git branch -r#查看远程分支$ git branch -a#查看所有本地分支和远程分支 新建本地分支新建分支（不切换）： 1$ git branch &lt;new_branch&gt; 新建分支并切换到新分支： 1234$ git checkout -b &lt;new_branch&gt;#相当于：$ git branch &lt;new_branch&gt;$ git checkout &lt;new_branch&gt; 删除本地分支12345$ git branch -d &lt;branch&gt;#删除分支前检查该分支是否有未提交或者未合并的内容$ git branch -D &lt;branch&gt;#强制删除该分支 新建远程分支相当于把远程未添加的本地分支push到远程： 12$ git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;#建议远程与本地分支同名，同名时可省略远程分支名 删除远程分支相当于push一个本地的空分支： 12$ git push origin :&lt;remote_branch&gt;#本地分支为空 或者用--delete： 1$ git push origin --delete &lt;remote_branch&gt; 合并分支12345$ git merge &lt;branch&gt;#快进合并（指针指向改变），合并&lt;branch&gt;到当前分支$ git merge --no-ff &lt;branch&gt;#合并&lt;branch&gt;到当前分支，在当前分支生成新节点，保证每个分支的独立演变史 撤销与版本回退撤销工作区修改有时修改工作区后，发现修改错误，希望回到原来未修改时（上一次提交或暂存）的状态。可以采用git checkout命令： 1234567$ git diff#查看工作区未提交（或为暂存）的文件的具体修改$ git checkout -- &lt;file&gt;#恢复工作区指定文件到上一次提交（或暂存）状态$ git checkout .#撤销所有工作区修改 撤销暂存12$ git reset HEAD &lt;file&gt;#将指定文件撤出暂存区 版本回退希望将版本库回退到之前的提交时，采用git reset命令： 12345678$ git log#查看之前的版本提交记录$ git reset HEAD^#回退到上一个提交版本，^^代表上两个版本，以此类推。（也可以用~2等代替）或$ git reset &lt;commitID&gt;#commitID可由git log查看得到 有必要整理一下git reset命令的三个参数： 123456789$ git reset --soft HEAD^#重置版本库头指针，且将这次提交之后的所有变更移动到暂存区$ git reset --mixed HEAD^#默认参数，等同于 git reset HEAD^#重置版本库头指针和暂存区，即这次提交之后的所有更改都留在工作区$ git reset --hard HEAD^#重置版本库头指针、暂存区和工作区，即这次提交之后的所有更改都不在存在于当前状态 在没有将之后的提交推送到远程仓库的情况下，git reset --hard是个很危险的操作。若是已经推送到远程仓库，使用git pull可以重新获得之后的版本提交。若是在没有远程备份时使用--hard进行版本回退，又想恢复到之后的版本，在一定时间内（一般为30天）可以通过git reflog查看操作id，再使用git reset --hard &lt;ID&gt;恢复。 stash储藏有时手头的工作进行到一半，需要切换分支做一些其他事情，可以采用git stash命令将当前的工作区储藏起来。 12345678910111213$ git stash#储藏当前工作区$ git stash list#查看当前的stash储藏栈$ git stash apply#应用栈顶的储藏内容，恢复工作区到之前的储藏状态$ git stash apply stash@&#123;2&#125;#应用指定储藏内容$ git stash pop#与apply类似，但从栈中删除该储藏内容 多人协作推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 12345#默认推送的为master主分支$ git push origin master#如果要推送其他分支，将该分支对应的名字来替换master即可$ git push origin dev 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 12#注意：本地分支名称最好与远程分支保持一致。$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程。 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你对同样的文件也做了修改，并且试图推送。 这个时候会推送失败,因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单: 先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。 1$ git pull 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 1$ git branch --set-upstream branch-name origin/branch-name 最后再将你改好的分支push到远程仓库。这就是多人协作的工作模式，一旦熟悉了，就非常简单。 其他状态查看1$ git status 任何情况下都可以使用git status命令查看当前的版本控制状态（包括工作区、暂存区、仓库区），并给出当前状态下可能会用到的命令提示。经常使用该命令是好习惯。 查看远程库信息1$ git remote -v 配置git用户123$ git config user.name "your name"$ git config user.email "email@example.com"#配置当前目录的git用户，加上--config参数时配置这台机器的所有git仓库 协议更改有时版本克隆是采用的是https协议，以至于每一次提交都需要输入用户名密码，很麻烦。而使用ssh协议就会方便很多，需要将当前的仓库协议进行更换。事实上，重置远程仓库名为ssh协议地址就可以了。 1$ git remote origin set-url git@example.com....]]></content>
      <categories>
        <category>版本控制之Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何更改Github上面托管的项目的默认显示语言]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9Github%E4%B8%8A%E9%9D%A2%E6%89%98%E7%AE%A1%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[最近将自己一门课的课程大作业，也算是一个小项目demo，放到了GitHub上面，由于项目里面包含许多下载的html文件，导致html代码远远的超过自己写的python代码，于是GitHub默认也就显示是html。 这种对于我这种有强迫症的人来说，简直就是不能忍受的。于是我就各种上网找解决方案。终于，在不懈的努力之后，让我给找到了，在这里分享给大家。 导致这种情况的主要原因是GitHub是使用Linguist来检测你的项目所使用的语言，Linguist具体的作用我个人猜测应该就是：统计你这个项目里面哪一种语言的代码量最多，就把这种语言作为当前这个项目的主语言,也就是默认显示语言。这种做法显然是很不合理的，你比如像python这种支持函数式编程而且崇尚语法简洁优雅的解释型脚本语言，它的代码量远远比不过其他的编译型语言(比如C/C++/Java)。 那么到底如何来解决这个问题呢？解决办法如下： 使用.gitattributes配置文件 具体做法是这样的：在你的GitHub代码仓库的根目录界面新建一个.gitattributes配置文件，如下图所示： 然后打开这个文件：把默认的显示语言（也就是统计的代码量最多的语言）全部改成你这个项目本来的语言。例如： 123*.js linguist-language=Python *.css linguist-language=Python *.html linguist-language=Python 这几行代码的意思就是说：将以.js , .css , .html 为扩展名的文件都按照Python语言来统计。就是这么简单。这么直接！！！ 好了，改完这些之后保存，再回到GitHub主界面就会看到默认的展示语言已经变成python了。主要的步骤就是这样，希望能够帮助到大家。]]></content>
      <categories>
        <category>版本控制之Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于惠普暗影精灵2 pro用一段时间之后，插上电源充不了电的问题]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%85%B3%E4%BA%8E%E6%83%A0%E6%99%AE%E6%9A%97%E5%BD%B1%E7%B2%BE%E7%81%B52-pro%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%8F%92%E4%B8%8A%E7%94%B5%E6%BA%90%E5%85%85%E4%B8%8D%E4%BA%86%E7%94%B5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[去年5月份换的新电脑，用到现在大半年了。近几天来突然发现电脑插上电源充不了电，关机重启啥的都没有效果，于是尝试着上网找各种解决方案，终于，在试了N种解决方案之后，终于让我成功地找到了解决问题的办法。现在将我的解决方案分享出来，希望对大家有所帮助。 具体的操作步骤（仅针对惠普电脑，其他品牌的电脑不敢保证，不过个人觉得应该差不多）如下： 先将电脑关机； 在关机状态下按住键盘上的windows和V键； 再按住上面的两个键的同时，不松开，再按住电源键，三个键同时按住不放2-3秒钟； 松开全部的按键； 按电源键开机，看是否会进入一个Bios设置界面，即是否会提示502，如果提示的话则表示操作成功； 再重新启动电脑一次，问题即可解决。]]></content>
      <categories>
        <category>电脑技巧</category>
      </categories>
      <tags>
        <tag>Computer Tricks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
